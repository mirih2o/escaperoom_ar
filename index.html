<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <title>AR Puzzle Game</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter and Indie Flower -->
    <link
      href="https://fonts.googleapis.com/css2?family=Indie+Flower&family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <!-- THREE.js library (required by AR.js THREEx) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- AR.js THREEx for marker detection -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex.js"></script>
    <style>
      :root {
        /* Primary antique brown colors */
        --color-brown-dark: #5d4636;
        --color-brown-medium: #7f5f4d;
        --color-brown-light: #bb9872;
        --color-brown-lighter: #ccaa79;

        /* Cream and light colors */
        --color-bg-cream: #f8f6f3;
        --color-text-cream: #f5f5dc;
        --bg-cream-translucent: rgba(248, 246, 243, 0.95);
        --bg-cream-solid: rgba(248, 246, 243, 1);

        /* Symbol colors - enhanced for better visibility */
        --color-symbol-flame: #ff5722; /* Warmer orange-red for flame */
        --color-symbol-gear: #546b56; /* Greenish-gray for gear */
        --color-symbol-eye: #0c91a2; /* Turquoise blue for eye */
        --color-symbol-star: #ffc107; /* Golden yellow for star */
        --color-symbol-moon: #9575cd; /* Soft purple for moon */
        --color-symbol-sun: #ff9800; /* Vibrant orange for sun */
        
        /* UI component colors */
        --color-trophy: #f59e0b; /* Golden trophy color */
        --color-note-bg: #fffdf0; /* Paper note background */
        --color-note-line: #f0e6d2; /* Paper note line pattern */

        /* Transparency variables */
        --overlay-opacity: rgba(0, 0, 0, 0.6);
        --brown-shadow-light: rgba(125, 95, 73, 0.15);
        --brown-shadow-medium: rgba(125, 95, 73, 0.4);
        --brown-shadow-dark: rgba(125, 95, 73, 0.5);
        --brown-border: rgba(187, 152, 114, 0.3);
        --brown-border-hover: rgba(187, 152, 114, 0.5);

        /* Gray and utility colors */
        --border-gray-light: rgba(229, 231, 235, 1);
        --text-gray-dark: rgb(18, 21, 26);
        --text-gray-medium: rgb(50, 55, 63);
        --text-gray-light: rgba(75, 85, 99, 1);
        
        /* Success colors */
        --bg-success-light: rgba(240, 253, 244, 1);
        --border-success-light: rgba(167, 243, 208, 1);
        --text-success: rgba(22, 101, 52, 1);
        --text-success-muted: rgba(21, 128, 61, 1);
        
        /* Drop shadow values */
        --drop-shadow-normal: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
        --drop-shadow-lifted: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        
        /* Animation timing */
        --transition-fast: 0.2s ease;
        --transition-normal: 0.3s ease;
        --transition-slow: 0.5s ease;
      }

      /* Custom styles to mimic Spark components or enhance appearance */
      .dialog-overlay {
        background-color: var(--overlay-opacity);
        backdrop-filter: blur(4px);
      }

      .dialog-content {
        background-color: var(--color-bg-cream);
        border-radius: 0.75rem;
        padding: 1.5rem;
        box-shadow: 0 20px 25px -5px var(--brown-shadow-light),
          0 10px 10px -5px var(--brown-shadow-light);
        max-width: 24rem; /* max-w-sm */
        width: 90%; /* w-11/12 */
        border: 1px solid var(--brown-border);
      }

      .btn-primary {
        background: linear-gradient(
          135deg,
          var(--color-brown-dark) 0%,
          var(--color-brown-medium) 50%,
          var(--color-brown-light) 100%
        );
        color: var(--color-text-cream);
        padding: 1rem 2rem;
        border-radius: 1rem;
        font-weight: 600;
        transition: all 0.3s ease;
        min-height: 60px;
        font-size: 1rem;
        border: none;
        box-shadow: 0 4px 15px var(--brown-shadow-medium);
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px var(--brown-shadow-dark);
        background: linear-gradient(
          135deg,
          var(--color-brown-medium) 0%,
          var(--color-brown-light) 50%,
          var(--color-brown-lighter) 100%
        );
      }

      .btn-primary:active {
        transform: translateY(0);
        box-shadow: 0 2px 10px var(--brown-shadow-medium);
      }

      .btn-secondary {
        background: var(--bg-cream-translucent);
        color: var(--color-brown-dark);
        padding: 0.5rem 0.75rem;
        border-radius: 0.5rem;
        font-weight: 500;
        transition: all 0.3s ease;
        min-height: 44px;
        min-width: 44px;
        font-size: 0.75rem;
        border: 2px solid var(--brown-border);
        backdrop-filter: blur(10px);
        box-shadow: 0 2px 10px var(--brown-shadow-light);
      }

      .btn-secondary:hover {
        background: var(--bg-cream-solid);
        transform: translateY(-1px);
        box-shadow: 0 4px 15px var(--brown-shadow-light);
        border-color: var(--brown-border-hover);
      }
      
      /* Message boxes and containers */
      .message-box {
        background-color: var(--bg-cream-translucent);
        backdrop-filter: blur(4px);
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px -1px var(--brown-shadow-light);
        border: 1px solid var(--brown-border);
        max-width: 28rem;
        margin-left: auto;
        margin-right: auto;
      }
      
      .message-box-fixed-width {
        max-width: 24rem;
      }
      
      .hint-content {
        line-height: 1.4;
      }
      
      .hint-text {
        font-style: italic;
        text-align: center;
        margin-bottom: 0.75rem;
      }
      
      .hint-symbol-text {
        font-size: 1.05rem;
      }
      
      .hint-symbol-emoji {
        margin-top: 2px;
        font-size: 1.125rem;
      }
      
      .icon-align-text-bottom {
        vertical-align: text-bottom;
      }
      
      .trophy-icon {
        color: var(--color-trophy);
      }
      
      .fixed-bottom-panel {
        position: fixed;
        left: 0.5rem;
        right: 0.5rem;
        bottom: 100px;
        z-index: 20;
        margin-right: auto;
      }
      
      .message-box-success {
        background-color: var(--bg-success-light);
        border-color: var(--border-success-light);
      }
      
      /* Paper note styling for hints */
      .paper-note {
        background-color: var(--color-note-bg);
        padding: 0.75rem;
        border-radius: 2px;
        box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
        transform: rotate(-1deg);
        position: relative;
        font-family: 'Indie Flower', 'Inter', sans-serif;
        max-width: 28rem;
        margin-left: auto;
        margin-right: auto;
        border: none;
      }
      
      .paper-note-title {
        font-weight: 600;
        font-size: 1.15rem;
        margin-bottom: 0.75rem;
        text-align: center;
        text-decoration: underline;
        color: var(--color-brown-dark);
      }
      
      .paper-note-tape {
        position: absolute;
        width: 100px;
        height: 30px;
        background-color: rgba(255, 255, 255, 0.6);
        top: -15px;
        left: 50%;
        transform: translateX(-50%) rotate(2deg);
        opacity: 0.7;
        box-shadow: 0 1px 3px rgba(0,0,0,0.12);
        z-index: -1;
      }
      
      /* Status indicators */
      .status-indicator {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.25rem;
        font-size: 0.75rem;
      }
      
      .status-indicator-dot {
        width: 0.375rem;
        height: 0.375rem;
        border-radius: 9999px;
      }
      
      .status-indicator-active {
        color: var(--text-success);
      }
      
      .status-indicator-active .status-indicator-dot {
        background-color: var(--text-success);
        animation: pulse 2s infinite;
      }
      
      /* Symbol styling */
      .symbol {
        position: absolute;
        cursor: move;
        font-size: 1.5rem;
        user-select: none;
        touch-action: none;
        transform: translate(-50%, -50%);
        transition: var(--transition-normal);
        filter: var(--drop-shadow-normal);
      }
      
      .symbol-dragging {
        z-index: 10;
        filter: var(--drop-shadow-lifted);
        transition: none;
      }
      
      /* Text styles */
      .text-title {
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--text-gray-dark);
        margin-bottom: 0.75rem;
      }
      
      .text-subtitle {
        font-size: 1rem;
        font-weight: 500;
        color: var(--text-gray-medium);
        margin-bottom: 0.5rem;
      }
      
      .m-0 {
        margin: 0;
      }
      
      .text-body {
        font-size: 0.875rem;
        color: var(--text-gray-medium);
      }
      
      /* Responsive text sizing */
      @media (min-width: 640px) {
        .symbol { font-size: 2rem; }
        .text-title { font-size: 1.5rem; }
      }
      
      @media (min-width: 768px) {
        .symbol { font-size: 2.5rem; }
      }
      
      /* Animations */
      @keyframes pulse {
        0% {
          opacity: 0.6;
          transform: scale(0.8);
        }
        50% {
          opacity: 1;
          transform: scale(1.2);
        }
        100% {
          opacity: 0.6;
          transform: scale(0.8);
        }
      }
      
      .animate-pulse {
        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- React CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>
    <!-- Babel CDN for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useState, useRef, useEffect } = React;
      const { createRoot } = ReactDOM;

      // Inline SVG Icons (Phosphor Icons replacements)
      const TrophyIcon = ({ size = 24, className = "" }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          fill="currentColor"
          viewBox="0 0 256 256"
          className={className}
        >
          <path d="M228,104a12.1,12.1,0,0,0-12,12V160a48,48,0,0,1-48,48H88a48,48,0,0,1-48-48V116a12.1,12.1,0,0,0-12-12,12,12,0,0,0,0,24v40a24,24,0,0,0,24,24h88a24,24,0,0,0,24-24V128a12,12,0,0,0,24,0v-12A12.1,12.1,0,0,0,228,104Zm-96-8A64,64,0,0,0,68,92V36a12,12,0,0,1,24,0V92a40,40,0,0,1,80,0V36a12,12,0,0,1,24,0V92A64,64,0,0,0,132,96Zm92-48a12,12,0,0,0-12-12H48a12,12,0,0,0,0,24H212A12,12,0,0,0,224,48Z"></path>
        </svg>
      );

      const CameraIcon = ({ size = 24, className = "" }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          fill="currentColor"
          viewBox="0 0 256 256"
          className={className}
        >
          <path d="M216,48H176L160,28A16,16,0,0,0,146.51,20H109.49A16,16,0,0,0,96,28L80,48H40A24,24,0,0,0,16,72V200a24,24,0,0,0,24,24H216a24,24,0,0,0,24-24V72A24,24,0,0,0,216,48ZM128,192a48,48,0,1,1,48-48A48.05,48.05,0,0,1,128,192Zm0-72a24,24,0,1,0,24,24A24,24,0,0,0,128,120Z"></path>
        </svg>
      );

      const ArrowCounterClockwiseIcon = ({ size = 24, className = "" }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          fill="currentColor"
          viewBox="0 0 256 256"
          className={className}
        >
          <path d="M224,128a96,96,0,0,1-192,0,12,12,0,0,1,24,0,72,72,0,1,0,144,0,12,12,0,0,1,24,0Zm-91.13,10.34a12,12,0,0,0,17.43-1.63L168,96.34V64a12,12,0,0,0-24,0V82.34L117.63,65.34a12,12,0,0,0-15.5,18.17l23.5,20Z"></path>
        </svg>
      );

      const GridIcon = ({ size = 24, className = "" }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          fill="currentColor"
          viewBox="0 0 256 256"
          className={className}
        >
          <path d="M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM112,200H40V144h72Zm0-72H40V72h72Zm24,72v-56h72V200Zm72-72H136V72h72Z"></path>
        </svg>
      );

      const CaretRightIcon = ({ size = 24, className = "" }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          fill="currentColor"
          viewBox="0 0 256 256"
          className={className}
        >
          <path d="M184.49,136.49l-80,80a12,12,0,0,1-17-17L159,128,87.51,56.49a12,12,0,1,1,17-17l80,80A12,12,0,0,1,184.49,136.49Z"></path>
        </svg>
      );

      const LightbulbFilamentIcon = ({ size = 24, className = "" }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          fill="currentColor"
          viewBox="0 0 256 256"
          className={className}
        >
          <path d="M128,24A96,96,0,0,0,51,180.3L40.7,208H215.3l-10.3-27.7A96,96,0,0,0,128,24Zm-4.1,137.9a12,12,0,0,1-16.1,4.4,12,12,0,0,1-4.4-16.1L121.9,128,107.4,98.6a12,12,0,0,1,4.4-16.1,12,12,0,0,1,16.1,4.4L134.1,128l14.5,29.4A12,12,0,0,1,123.9,161.9ZM168,208v16a8,8,0,0,1-16,0V208ZM88,208v16a8,8,0,0,1-16,0V208Z"></path>
        </svg>
      );

      // Calculate grid cell size based on viewport
      const GRID_SIZE = 3;
      const TOLERANCE = 50; // Fixed tolerance value

      // Define stages with their symbols and winning positions
      const STAGES = [
        {
          symbols: {
            flame: {
              emoji: "🔥",
              position: null, // Will be calculated dynamically
              hint: "The flame burns brightest on the right",
            },
            gear: {
              emoji: "⚙️",
              position: null, // Will be calculated dynamically
              hint: "The gear sits in a corner",
            },
            eye: {
              emoji: "👁️",
              position: null, // Will be calculated dynamically
              hint: "The eye watches from above",
            },
          },
          winningPositions: {
            flame: { col: 2, row: 1 }, // Middle-right
            gear: { col: 0, row: 2 }, // Bottom-left
            eye: { col: 1, row: 0 }, // Top-center
          },
          neutralHints: {
            hint: "Each column and row has 1 symbol",
          },
        },
        {
          symbols: {
            flame: {
              emoji: "🔥",
              position: null, // Will be calculated dynamically
              hint: "The flame glows from above",
            },
            gear: {
              emoji: "⚙️",
              position: null, // Will be calculated dynamically
              hint: "The gear turns in harmony with others",
            },
            eye: {
              emoji: "👁️",
              position: null, // Will be calculated dynamically
              hint: "The eye keeps balance in the center",
            },
            star: {
              emoji: "⭐",
              position: null, // Will be calculated dynamically
              hint: "The star guides from the eastern edge",
            },
            moon: {
              emoji: "🌙",
              position: null, // Will be calculated dynamically
              hint: "The moon reflects light from below",
            },
            sun: {
              emoji: "☀️",
              position: null, // Will be calculated dynamically
              hint: "The sun brings warmth to the west",
            },
          },
          neutralHints: {
            hint: "Arrange the symbols.",
          },
          winningPositions: {
            flame: { col: 1, row: 0 }, // Top-center
            gear: { col: 0, row: 1 }, // Middle-left
            eye: { col: 1, row: 1 }, // Center
            star: { col: 2, row: 1 }, // Middle-right
            moon: { col: 1, row: 2 }, // Bottom-center
            sun: { col: 0, row: 0 }, // Top-left
          },
        },
      ];

      function App() {
        const [currentStage, setCurrentStage] = useState(0);
        const [isARActive, setIsARActive] = useState(false);
        const [arInitialized, setArInitialized] = useState(false);
        const [arError, setArError] = useState(null);
        const [showSuccess, setShowSuccess] = useState(false);
        const [showGrid, setShowGrid] = useState(false);
        const [showHints, setShowHints] = useState(false);
        const [draggedSymbol, setDraggedSymbol] = useState(null);
        const [cursorPosition, setCursorPosition] = useState({ x: 0, y: 0 }); // Not currently used for symbol position
        // Track which symbols have been discovered via AR markers
        const [discoveredSymbols, setDiscoveredSymbols] = useState(new Set());
        const [positions, setPositions] = useState({});
        const [showAllSymbolsFoundMessage, setShowAllSymbolsFoundMessage] =
          useState(false);
        const [showFallbackButtons, setShowFallbackButtons] = useState(false);

        const [cellSize, setCellSize] = useState(0);
        const [gridOffsetX, setGridOffsetX] = useState(0);
        const [gridOffsetY, setGridOffsetY] = useState(0);

        const videoRef = useRef(null);
        const containerRef = useRef(null);
        const arToolkitSourceRef = useRef(null);
        const arToolkitContextRef = useRef(null);
        const markerControlsRef = useRef({});

        // Calculate initial symbol positions based on available space
        const calculateInitialPositions = (stage) => {
          const topUIHeight = 80;
          const sidePadding = 40; // More generous padding

          // Calculate symbol area (above the grid)
          const symbolAreaWidth = window.innerWidth - sidePadding * 2;
          const symbolAreaTop = 10; // Small margin from very top
          const symbolAreaHeight = 50; // Height for symbol placement

          const symbols = Object.keys(STAGES[stage].symbols);
          const positions = {};

          // Arrange symbols horizontally with even spacing
          if (symbols.length > 0) {
            symbols.forEach((symbol, index) => {
              const spacing = symbolAreaWidth / symbols.length;
              const xOffset = spacing * index + spacing / 2;

              positions[symbol] = {
                x: sidePadding + xOffset,
                y: symbolAreaTop + symbolAreaHeight / 2,
              };
            });
          }

          return positions;
        };

        // AR marker detection function
        const onMarkerDetected = (markerId) => {
          // Map marker IDs to symbol names
          const markerToSymbol = {
            eye: "eye",
            flame: "flame",
            gear: "gear",
          };

          const symbolName = markerToSymbol[markerId];
          if (symbolName && currentStage === 0) {
            setDiscoveredSymbols((prev) => new Set([...prev, symbolName]));
          }
        };

        // Implement actual AR marker detection
        const initializeAR = () => {
          console.log("Initializing AR marker detection...");

          // Check if AR.js is properly loaded
          if (typeof THREEx === "undefined" || typeof THREE === "undefined") {
            console.warn("AR.js libraries not fully loaded, using manual mode");
            setArError("AR libraries not loaded");
            setArInitialized(true);
            return;
          }

          try {
            // Create AR toolkit source with camera access
            arToolkitSourceRef.current = new THREEx.ArToolkitSource({
              sourceType: "webcam",
              sourceWidth: window.innerWidth,
              sourceHeight: window.innerHeight,
              displayWidth: window.innerWidth,
              displayHeight: window.innerHeight,
            });

            arToolkitSourceRef.current.init(
              () => {
                console.log("AR source initialized successfully");

                // Show the camera feed in the video element
                if (videoRef.current && arToolkitSourceRef.current.domElement) {
                  // Copy the video stream to our video element for display
                  const sourceVideo = arToolkitSourceRef.current.domElement;
                  if (sourceVideo.srcObject) {
                    videoRef.current.srcObject = sourceVideo.srcObject;
                    videoRef.current.play();
                  }
                }

                // Create AR toolkit context
                arToolkitContextRef.current = new THREEx.ArToolkitContext({
                  cameraParametersUrl:
                    "https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/data/data/camera_para.dat",
                  detectionMode: "mono_and_matrix",
                  matrixCodeType: "3x3",
                  canvasWidth:
                    arToolkitSourceRef.current.parameters.sourceWidth,
                  canvasHeight:
                    arToolkitSourceRef.current.parameters.sourceHeight,
                });

                arToolkitContextRef.current.init(
                  () => {
                    console.log("AR context initialized successfully");

                    // Create Three.js scene for AR
                    const scene = new THREE.Scene();
                    const camera = new THREE.Camera();
                    scene.add(camera);

                    // Setup markers for each pattern file
                    const markers = [
                      { id: "eye", patternUrl: "./markers/eye.patt" },
                      { id: "flame", patternUrl: "./markers/flame.patt" },
                      { id: "gear", patternUrl: "./markers/gear.patt" },
                    ];

                    markers.forEach((marker) => {
                      const markerRoot = new THREE.Group();
                      scene.add(markerRoot);

                      const markerControls = new THREEx.ArMarkerControls(
                        arToolkitContextRef.current,
                        markerRoot,
                        {
                          type: "pattern",
                          patternUrl: marker.patternUrl,
                          changeMatrixMode: "cameraTransformMatrix",
                        }
                      );

                      // Store reference
                      markerControlsRef.current[marker.id] = markerControls;

                      // Track marker visibility
                      let isMarkerVisible = false;

                      // Create a detection loop for this marker
                      const checkMarkerVisibility = () => {
                        const wasVisible = isMarkerVisible;
                        isMarkerVisible = markerRoot.visible;

                        if (!wasVisible && isMarkerVisible) {
                          console.log(`Marker ${marker.id} detected!`);
                          onMarkerDetected(marker.id);
                        } else if (wasVisible && !isMarkerVisible) {
                          console.log(`Marker ${marker.id} lost`);
                        }
                      };

                      // Add to detection loop
                      markerControlsRef.current[marker.id].checkVisibility =
                        checkMarkerVisibility;
                    });

                    // Start the AR render loop
                    startARRenderLoop();

                    console.log("AR marker detection fully initialized");
                    setArInitialized(true);
                  },
                  (error) => {
                    console.error("AR context initialization failed:", error);
                    setArError("AR context failed");
                    setArInitialized(true); // Fallback to manual mode
                  }
                );
              },
              (error) => {
                console.error("AR source initialization failed:", error);
                setArError("Camera access failed");
                setArInitialized(true); // Fallback to manual mode
              }
            );
          } catch (error) {
            console.error("AR initialization error:", error);
            setArError("AR initialization failed");
            setArInitialized(true); // Fallback to manual mode
          }
        };

        // AR render loop with marker detection
        const startARRenderLoop = () => {
          const animate = () => {
            requestAnimationFrame(animate);

            if (arToolkitSourceRef.current && arToolkitContextRef.current) {
              if (arToolkitSourceRef.current.ready) {
                arToolkitContextRef.current.update(
                  arToolkitSourceRef.current.domElement
                );

                // Check marker visibility for each marker
                Object.values(markerControlsRef.current).forEach(
                  (markerControls) => {
                    if (markerControls.checkVisibility) {
                      markerControls.checkVisibility();
                    }
                  }
                );
              }
            }
          };
          animate();
        };

        // Cleanup AR resources
        const cleanupAR = () => {
          if (arToolkitContextRef.current) {
            arToolkitContextRef.current.dispose();
            arToolkitContextRef.current = null;
          }
          if (arToolkitSourceRef.current) {
            arToolkitSourceRef.current = null;
          }
          markerControlsRef.current = {};

          setArInitialized(false);
        };

        // Effect to reveal grid when all symbols are discovered in stage 1
        useEffect(() => {
          if (currentStage === 0 && discoveredSymbols.size === 3) {
            setShowGrid(true);
            setShowAllSymbolsFoundMessage(true);

            // Fade out the message after 3 seconds
            const timer = setTimeout(() => {
              setShowAllSymbolsFoundMessage(false);
            }, 3000);

            return () => clearTimeout(timer);
          }
        }, [discoveredSymbols, currentStage]);

        // Initial setup effect
        useEffect(() => {
          // Set initial positions on component mount
          const initialPositions = calculateInitialPositions(currentStage);
          setPositions(initialPositions);
        }, []);

        // Cleanup AR resources on unmount
        useEffect(() => {
          return () => {
            cleanupAR();
          };
        }, []);

        // Update grid dimensions and symbol positions on window resize
        useEffect(() => {
          const updateGridDimensions = () => {
            // Account for UI elements and safe areas
            const topUIHeight = 80; // Reduced space for top messages/indicators
            const bottomUIHeight = 120; // Reduced space for bottom controls
            const sidePadding = 20; // Minimum side padding

            const availableWidth = window.innerWidth - sidePadding * 2;
            const availableHeight =
              window.innerHeight - topUIHeight - bottomUIHeight;
            const minDimension = Math.min(availableWidth, availableHeight);

            // Ensure grid fits well on screen with minimum cell size
            const newCellSize = Math.max(70, Math.min(110, minDimension / 3.5));
            setCellSize(newCellSize);

            // Center horizontally
            setGridOffsetX(
              window.innerWidth / 2 - (GRID_SIZE * newCellSize) / 2
            );

            // Center vertically in the available space
            const gridHeight = GRID_SIZE * newCellSize;
            setGridOffsetY(topUIHeight + (availableHeight - gridHeight) / 2);

            // Calculate and set initial positions for symbols
            const initialPositions = calculateInitialPositions(currentStage);
            setPositions((prev) => ({ ...prev, ...initialPositions }));
          };

          updateGridDimensions();
          window.addEventListener("resize", updateGridDimensions);
          // Also update on orientation change for mobile
          window.addEventListener("orientationchange", () => {
            setTimeout(updateGridDimensions, 100);
          });

          return () => {
            window.removeEventListener("resize", updateGridDimensions);
            window.removeEventListener(
              "orientationchange",
              updateGridDimensions
            );
          };
        }, [currentStage]); // Add currentStage as dependency

        // Handle touch events with non-passive listeners to prevent warnings
        useEffect(() => {
          const handleTouchStartNonPassive = (e) => {
            const target = e.target;
            const symbolElement = target.closest("[data-symbol]");

            if (symbolElement) {
              e.preventDefault();
              const symbol = symbolElement.getAttribute("data-symbol");
              setDraggedSymbol(symbol);
            }
          };

          const handleTouchMoveNonPassive = (e) => {
            // Check if the target is the container or a draggable symbol
            const container = containerRef.current;
            const target = e.target;

            if (!container) return;

            // If it's the container or a child of the container
            if (container.contains(target)) {
              e.preventDefault();

              // Get touch coordinates
              const touch = e.touches?.[0] || e.changedTouches?.[0];
              const clientX = touch?.clientX || e.clientX;
              const clientY = touch?.clientY || e.clientY;

              const containerRect = container.getBoundingClientRect();
              const x = clientX - containerRect.left;
              const y = clientY - containerRect.top;

              // Check if it's a draggable symbol (has data-symbol attribute)
              const symbolElement = target.closest("[data-symbol]");
              if (symbolElement) {
                // Handle symbol dragging
                setPositions((prev) => {
                  const currentDraggedSymbol = Object.keys(prev).find(
                    (symbol) =>
                      document.querySelector(`[data-symbol="${symbol}"]`) ===
                      symbolElement
                  );

                  if (!currentDraggedSymbol) return prev;

                  // Check if within grid bounds for snapping
                  const col = Math.floor((x - gridOffsetX) / cellSize);
                  const row = Math.floor((y - gridOffsetY) / cellSize);

                  if (
                    col >= 0 &&
                    col < GRID_SIZE &&
                    row >= 0 &&
                    row < GRID_SIZE
                  ) {
                    // Snap to grid
                    const snappedX = gridOffsetX + (col + 0.5) * cellSize;
                    const snappedY = gridOffsetY + (row + 0.5) * cellSize;
                    return {
                      ...prev,
                      [currentDraggedSymbol]: { x: snappedX, y: snappedY },
                    };
                  } else {
                    // Follow cursor if not within grid
                    return {
                      ...prev,
                      [currentDraggedSymbol]: { x, y },
                    };
                  }
                });
              } else {
                // Handle cursor tracking
                setCursorPosition({ x, y });
              }
            }
          };

          const handleTouchEndNonPassive = (e) => {
            const target = e.target;
            const symbolElement = target.closest("[data-symbol]");

            if (symbolElement) {
              e.preventDefault();

              // Get the symbol being dropped
              const symbol = symbolElement.getAttribute("data-symbol");

              // Handle drop logic
              setPositions((prevPositions) => {
                const currentPos = prevPositions[symbol];
                if (!currentPos) return prevPositions;

                const col = Math.floor((currentPos.x - gridOffsetX) / cellSize);
                const row = Math.floor((currentPos.y - gridOffsetY) / cellSize);

                let updatedPositions = prevPositions;

                // Check if the cell is within grid bounds
                if (
                  col >= 0 &&
                  col < GRID_SIZE &&
                  row >= 0 &&
                  row < GRID_SIZE
                ) {
                  // Check if any other symbol is in this cell
                  const occupyingSymbol = Object.entries(prevPositions).find(
                    ([otherSymbol, pos]) => {
                      if (otherSymbol === symbol) return false;
                      const otherCol = Math.floor(
                        (pos.x - gridOffsetX) / cellSize
                      );
                      const otherRow = Math.floor(
                        (pos.y - gridOffsetY) / cellSize
                      );
                      return otherCol === col && otherRow === row;
                    }
                  );

                  if (!occupyingSymbol) {
                    // Cell is free, snap to grid center
                    updatedPositions = {
                      ...prevPositions,
                      [symbol]: {
                        x: gridOffsetX + (col + 0.5) * cellSize,
                        y: gridOffsetY + (row + 0.5) * cellSize,
                      },
                    };
                  } else {
                    // If cell is occupied, send the other symbol back to its initial position
                    // and place this symbol in the cell
                    const [otherSymbol] = occupyingSymbol;
                    const initialPositions = calculateInitialPositions(currentStage);
                    updatedPositions = {
                      ...prevPositions,
                      [symbol]: {
                        x: gridOffsetX + (col + 0.5) * cellSize,
                        y: gridOffsetY + (row + 0.5) * cellSize,
                      },
                      [otherSymbol]: initialPositions[otherSymbol] || prevPositions[otherSymbol]
                    };
                  }
                } else {
                  // Return to original position if drop is invalid
                  const initialPositions =
                    calculateInitialPositions(currentStage);
                  updatedPositions = {
                    ...prevPositions,
                    [symbol]: initialPositions[symbol] || prevPositions[symbol],
                  };
                }

                // Check win condition with the updated positions
                setTimeout(() => {
                  let isWin = true;
                  const currentWinningPositions =
                    STAGES[currentStage].winningPositions;

                  Object.entries(updatedPositions).forEach(
                    ([sym, position]) => {
                      const target = currentWinningPositions[sym];
                      if (!target) {
                        isWin = false;
                        return;
                      }
                      const targetPixel = {
                        x: gridOffsetX + (target.col + 0.5) * cellSize,
                        y: gridOffsetY + (target.row + 0.5) * cellSize,
                      };
                      const distance = Math.sqrt(
                        Math.pow(targetPixel.x - position.x, 2) +
                          Math.pow(targetPixel.y - position.y, 2)
                      );

                      if (distance > TOLERANCE) {
                        isWin = false;
                      }
                    }
                  );

                  if (isWin) {
                    setShowSuccess(true);
                  }
                }, 50);

                return updatedPositions;
              });

              setDraggedSymbol(null);
            }
          };

          // Add non-passive touch listeners to document
          document.addEventListener("touchstart", handleTouchStartNonPassive, {
            passive: false,
          });
          document.addEventListener("touchmove", handleTouchMoveNonPassive, {
            passive: false,
          });
          document.addEventListener("touchend", handleTouchEndNonPassive, {
            passive: false,
          });

          return () => {
            document.removeEventListener(
              "touchstart",
              handleTouchStartNonPassive
            );
            document.removeEventListener(
              "touchmove",
              handleTouchMoveNonPassive
            );
            document.removeEventListener("touchend", handleTouchEndNonPassive);
          };
        }, [gridOffsetX, gridOffsetY, cellSize, currentStage]);

        // Convert grid position to pixel coordinates
        const gridToPixel = (col, row) => ({
          x: gridOffsetX + (col + 0.5) * cellSize,
          y: gridOffsetY + (row + 0.5) * cellSize,
        });

        // Convert pixel coordinates to grid position
        const pixelToGrid = (x, y) => ({
          col: Math.floor((x - gridOffsetX) / cellSize),
          row: Math.floor((y - gridOffsetY) / cellSize),
        });

        const getEventCoordinates = (e) => {
          const touch = e.touches?.[0] || e.changedTouches?.[0];
          return {
            clientX: touch?.clientX || e.clientX,
            clientY: touch?.clientY || e.clientY,
          };
        };

        const handlePointerMove = (e) => {
          const container = containerRef.current.getBoundingClientRect();
          const { clientX, clientY } = getEventCoordinates(e);
          const x = clientX - container.left;
          const y = clientY - container.top;
          setCursorPosition({ x, y });
        };

        const handleDragStart = (e, symbol) => {
          e.preventDefault();
          setDraggedSymbol(symbol);
        };

        const startAR = async () => {
          try {
            setIsARActive(true);

            // Try AR initialization first
            setTimeout(() => {
              initializeAR();

              // If AR fails, fallback to basic camera access after a delay
              setTimeout(() => {
                if (
                  arError &&
                  videoRef.current &&
                  !videoRef.current.srcObject
                ) {
                  console.log("AR failed, trying fallback camera access...");
                  navigator.mediaDevices
                    .getUserMedia({
                      video: { facingMode: "environment" },
                    })
                    .then((stream) => {
                      if (videoRef.current) {
                        videoRef.current.srcObject = stream;
                        videoRef.current.play();
                        console.log("Fallback camera initialized");
                      }
                    })
                    .catch((err) => {
                      console.error("Fallback camera access failed:", err);
                    });
                }
              }, 2000);
            }, 500);
          } catch (error) {
            console.error("Error starting AR:", error);
            // Provide a user-friendly message instead of alert
            const messageBox = document.createElement("div");
            messageBox.className =
              "fixed inset-0 flex items-center justify-center z-[100] dialog-overlay";
            messageBox.innerHTML = `
                        <div class="dialog-content text-center">
                            <h2 class="text-xl sm:text-2xl md:text-3xl font-semibold mb-6">AR Initialization Failed</h2>
                            <p class="text-base sm:text-lg md:text-xl mb-6">Please try again or use manual mode.</p>
                            <button class="mt-6 px-6 py-3 bg-blue-500 text-white rounded-lg text-base sm:text-lg md:text-xl hover:bg-blue-600 transition-colors font-medium" onclick="this.parentElement.parentElement.remove()">OK</button>
                        </div>
                    `;
            document.body.appendChild(messageBox);
          }
        };

        const checkWinCondition = () => {
          let isWin = true;
          const currentWinningPositions = STAGES[currentStage].winningPositions;

          Object.entries(positions).forEach(([symbol, position]) => {
            const target = currentWinningPositions[symbol];
            if (!target) {
              // Handle cases where a symbol might not have a winning position in the current stage
              isWin = false;
              return;
            }
            const targetPixel = gridToPixel(target.col, target.row);
            const distance = Math.sqrt(
              Math.pow(targetPixel.x - position.x, 2) +
                Math.pow(targetPixel.y - position.y, 2)
            );

            if (distance > TOLERANCE) {
              isWin = false;
            }
          });

          if (isWin) {
            setShowSuccess(true);
          }
        };

        const advanceToNextStage = () => {
          if (currentStage < STAGES.length - 1) {
            const nextStageIndex = currentStage + 1;
            setCurrentStage(nextStageIndex);
            // Reset positions for the new stage symbols will be handled by useEffect
            setShowSuccess(false);
            setShowHints(false); // Hide hints for new stage
            // Reset AR discovery for the new stage
            setDiscoveredSymbols(new Set());
            // For stages other than 1, show grid by default
            if (nextStageIndex !== 0) {
              setShowGrid(true);
            } else {
              setShowGrid(false);
            }
          }
        };

        const resetPositions = () => {
          const initialPositions = calculateInitialPositions(currentStage);
          setPositions((prev) => ({ ...prev, ...initialPositions }));
        };

        const snapToGrid = (x, y) => {
          // Calculate which grid cell we're closest to
          const col = Math.floor((x - gridOffsetX) / cellSize);
          const row = Math.floor((y - gridOffsetY) / cellSize);

          // Only snap if within grid bounds
          if (col >= 0 && col < GRID_SIZE && row >= 0 && row < GRID_SIZE) {
            return gridToPixel(col, row);
          }

          // Return original position if not within grid
          return { x, y };
        };

        const handleDrag = (e) => {
          if (!draggedSymbol) return;
          e.preventDefault();

          const container = containerRef.current.getBoundingClientRect();
          const { clientX, clientY } = getEventCoordinates(e);
          const x = clientX - container.left;
          const y = clientY - container.top;

          // Check if within grid bounds for snapping
          const col = Math.floor((x - gridOffsetX) / cellSize);
          const row = Math.floor((y - gridOffsetY) / cellSize);

          if (col >= 0 && col < GRID_SIZE && row >= 0 && row < GRID_SIZE) {
            const snappedPos = snapToGrid(x, y);
            setPositions((prev) => ({
              ...prev,
              [draggedSymbol]: snappedPos,
            }));
          } else {
            // Follow cursor if not within grid
            setPositions((prev) => ({
              ...prev,
              [draggedSymbol]: { x, y },
            }));
          }
        };

        const handleDragEnd = () => {
          if (!draggedSymbol) return;

          const currentPos = positions[draggedSymbol];
          const gridPos = pixelToGrid(currentPos.x, currentPos.y);

          // Check if the cell is within grid bounds
          if (
            gridPos.col >= 0 &&
            gridPos.col < GRID_SIZE &&
            gridPos.row >= 0 &&
            gridPos.row < GRID_SIZE
          ) {
            // Check if any other symbol is in this cell
            const occupyingSymbol = Object.entries(positions).find(
              ([symbol, pos]) => {
                if (symbol === draggedSymbol) return false;
                const otherGridPos = pixelToGrid(pos.x, pos.y);
                return (
                  otherGridPos.col === gridPos.col &&
                  otherGridPos.row === gridPos.row
                );
              }
            );

            // If cell is occupied, send the other symbol back to its original position
            if (occupyingSymbol) {
              const [symbol] = occupyingSymbol;
              const initialPositions = calculateInitialPositions(currentStage);
              setPositions((prev) => ({
                ...prev,
                [symbol]: initialPositions[symbol],
              }));
            }
          }

          setDraggedSymbol(null);
          checkWinCondition();
        };

        // Custom Dialog component replacement
        const CustomDialog = ({ open, onOpenChange, children }) => {
          if (!open) return null;
          return (
            <div
              className="fixed inset-0 flex items-center justify-center z-50 dialog-overlay"
              onClick={() => onOpenChange(false)}
            >
              <div
                className="dialog-content"
                onClick={(e) => e.stopPropagation()}
              >
                {children}
              </div>
            </div>
          );
        };

        // Custom Button component replacement
        const CustomButton = ({
          variant,
          icon,
          onClick,
          children,
          className,
          "aria-label": ariaLabel,
        }) => {
          const baseClasses =
            "flex items-center justify-center gap-2 font-medium transition-all";
          const variantClasses = {
            primary: "btn-primary",
            secondary: "btn-secondary",
          };

          return (
            <button
              className={`${baseClasses} ${variantClasses[variant]} ${
                className || ""
              }`}
              onClick={onClick}
              aria-label={ariaLabel}
            >
              {icon}
              {children}
            </button>
          );
        };

        return (
          <div
            className="w-full h-screen relative overflow-hidden"
            ref={containerRef}
            onDragOver={(e) => e.preventDefault()}
            onMouseMove={handlePointerMove}
            style={{ touchAction: "none" }}
          >
            <video
              ref={videoRef}
              className="w-full h-full object-cover"
              playsInline
              muted
              hidden={!isARActive}
            />

            {showGrid &&
              cellSize >
                0 /* Ensure cellSize is calculated before rendering grid */ && (
                <div
                  className="absolute grid grid-cols-3 grid-rows-3"
                  style={{
                    width: GRID_SIZE * cellSize,
                    height: GRID_SIZE * cellSize,
                    left: gridOffsetX,
                    top: gridOffsetY,
                  }}
                >
                  {Array.from({ length: 9 }).map((_, i) => (
                    <div
                      key={i}
                      className="backdrop-blur-sm"
                      style={{
                        border: "2px solid rgba(255, 255, 255, 0.6)",
                        backgroundColor: "rgba(255, 255, 255, 0.1)"
                      }}
                    />
                  ))}
                </div>
              )}

            {Object.entries(STAGES[currentStage].symbols)
              .filter(([symbol]) => {
                // In stage 1, only show symbols that have been discovered via AR markers
                return currentStage !== 0 || discoveredSymbols.has(symbol);
              })
              .map(([symbol, config]) => {
                // Ensure position exists, if not use fallback
                const symbolPosition = positions[symbol] || { x: 50, y: 50 };

                return (
                  <div
                    key={symbol}
                    className={`symbol ${draggedSymbol === symbol ? 'symbol-dragging' : ''}`}
                    data-symbol={symbol}
                    style={{
                      left: symbolPosition.x,
                      top: symbolPosition.y,
                      color: `var(--color-symbol-${symbol})`,
                      zIndex: draggedSymbol === symbol ? 10 : 5,
                    }}
                    draggable
                    onDragStart={(e) => handleDragStart(e, symbol)}
                    onDrag={handleDrag}
                    onDragEnd={handleDragEnd}
                  >
                    {config.emoji}
                  </div>
                );
              })}

            {showHints && (
              <div className="fixed-bottom-panel">
                <div className="paper-note">
                  <div className="paper-note-tape"></div>
                  <div className="paper-note-title">
                    <LightbulbFilamentIcon
                      className="inline mr-1 icon-align-text-bottom"
                      size={18}
                    />
                    Puzzle Hints
                  </div>
                  <div className="hint-content">
                    {STAGES[currentStage].neutralHints?.hint && (
                      <div className="hint-text">
                        "{STAGES[currentStage].neutralHints.hint}"
                      </div>
                    )}
                    {Object.entries(STAGES[currentStage].symbols)
                      .filter(([symbol]) => {
                        // In stage 1, only show hints for symbols that have been discovered via AR markers
                        return (
                          currentStage !== 0 || discoveredSymbols.has(symbol)
                        );
                      })
                      .map(([symbol, config]) => (
                        <div key={symbol} className="flex items-start gap-2 mb-2">
                          <span 
                            className="hint-symbol-emoji"
                            style={{color: `var(--color-symbol-${symbol})`}}
                          >{config.emoji}</span>
                          <span className="hint-symbol-text">{config.hint}</span>
                        </div>
                      ))}
                  </div>
                </div>
              </div>
            )}

            {!isARActive && (
              <div className="absolute inset-0 flex items-center justify-center z-10">
                <div className="text-center p-6 bg-white rounded-xl shadow-lg border message-box message-box-fixed-width">
                  <h2 className="text-title">
                    AR Puzzle Game
                  </h2>
                  <CustomButton
                    variant="primary"
                    icon={<CameraIcon size={20} />}
                    onClick={startAR}
                    className="w-full"
                  >
                    Start AR Experience
                  </CustomButton>
                  <p className="mt-3 text-body">
                    Find and scan AR markers to discover hidden symbols and
                    unlock the puzzle grid
                  </p>
                </div>
              </div>
            )}

            {/* AR Scanning Instructions for Stage 1 */}
            {isARActive && currentStage === 0 && discoveredSymbols.size < 3 && (
              <div className="message-box fixed top-2 left-2 right-2 z-20">
                <div className="text-center">
                  <h3 className="text-subtitle">
                    {arError
                      ? "⚠️ Using Manual Mode"
                      : arInitialized
                      ? "🔍 Find Hidden Symbols"
                      : "📷 Starting Camera..."}
                  </h3>
                  <p className="text-body mb-2">
                    {arError
                      ? "Camera ready - Use manual buttons below"
                      : arInitialized
                      ? "Point camera at markers or tap buttons below"
                      : "Setting up detection..."}
                  </p>
                  {arInitialized && (
                    <>
                      <div className="flex justify-center items-center gap-3 mb-2">
                        <span className="text-sm font-medium" style={{color: "var(--text-gray-medium)"}}>
                          {discoveredSymbols.size}/3
                        </span>
                        <div className="flex gap-1">
                          {["eye", "flame", "gear"].map((symbol) => (
                            <span
                              key={symbol}
                              className={`text-lg transition-all duration-300 ${
                                discoveredSymbols.has(symbol)
                                  ? "opacity-100 scale-110"
                                  : "opacity-20 scale-90"
                              }`}
                              style={{
                                color: discoveredSymbols.has(symbol) 
                                  ? `var(--color-symbol-${symbol})` 
                                  : 'inherit'
                              }}
                            >
                              {symbol === "eye"
                                ? "👁️"
                                : symbol === "flame"
                                ? "🔥"
                                : "⚙️"}
                            </span>
                          ))}
                        </div>
                      </div>
                      <div className="status-indicator status-indicator-active">
                        <div className="status-indicator-dot bg-green-600 animate-pulse"></div>
                        AR Active
                      </div>
                    </>
                  )}
                  {!arInitialized && (
                    <div className="flex justify-center items-center gap-2">
                      <div className="animate-spin rounded-full h-4 w-4 border-2 border-b-transparent border-blue-600"></div>
                      <button
                        onClick={() => setArInitialized(true)}
                        className="px-2 py-1 text-sm bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition-colors"
                      >
                        Skip
                      </button>
                    </div>
                  )}
                </div>
              </div>
            )}

            {/* Grid revealed message for Stage 1 */}
            {isARActive &&
              currentStage === 0 &&
              discoveredSymbols.size === 3 &&
              showGrid && (
                <div
                  className={`message-box message-box-success fixed top-20 left-2 right-2 z-20 transition-opacity duration-1000 ${
                    showAllSymbolsFoundMessage ? "opacity-100" : "opacity-0"
                  }`}
                >
                  <div className="text-center">
                    <h3 className="text-subtitle flex items-center justify-center gap-2" style={{color: "var(--text-success)"}}>
                      ✅ All Symbols Found!
                    </h3>
                    <p className="text-body" style={{color: "var(--text-success-muted)"}}>
                      Drag symbols to solve the puzzle.
                    </p>
                  </div>
                </div>
              )}

            {isARActive && (
              <div className="fixed bottom-0 left-0 right-0 z-20 p-2">
                {/* Development/Fallback AR testing buttons */}
                {currentStage === 0 && discoveredSymbols.size < 3 && (
                  <>
                    {/* AR not working prompt */}
                    {!showFallbackButtons && (
                      <div className="message-box mb-2 text-center">
                        <div className="flex items-center justify-center gap-2">
                          <span className="text-body">
                            AR not working?
                          </span>
                          <CustomButton
                            variant="secondary"
                            onClick={() => setShowFallbackButtons(true)}
                            className="text-sm px-2 py-1 min-w-fit"
                          >
                            Tap here
                          </CustomButton>
                        </div>
                      </div>
                    )}

                    {/* Fallback buttons - only show when requested */}
                    {showFallbackButtons && (
                      <div className="message-box mb-2">
                        <div className="text-subtitle text-center mb-1">
                          Tap to discover symbols manually
                        </div>
                        <div className="flex justify-center gap-2 flex-wrap">
                          {["eye", "flame", "gear"].map((symbol) => (
                            <button
                              key={symbol}
                              onClick={() => onMarkerDetected(symbol)}
                              disabled={discoveredSymbols.has(symbol)}
                              className={`px-3 py-2 rounded-lg text-sm font-medium transition-all flex-shrink-0 ${
                                discoveredSymbols.has(symbol)
                                  ? "bg-green-100 cursor-not-allowed"
                                  : "btn-secondary"
                              }`}
                              style={{
                                color: discoveredSymbols.has(symbol) 
                                  ? "var(--text-success)" 
                                  : `var(--color-symbol-${symbol})` 
                              }}
                            >
                              {symbol === "eye"
                                ? "👁️ Eye"
                                : symbol === "flame"
                                ? "🔥 Flame"
                                : "⚙️ Gear"}
                            </button>
                          ))}
                        </div>
                      </div>
                    )}
                  </>
                )}

                <div className="message-box flex flex-row justify-between items-center">
                  <div className="flex items-center gap-3">
                    <span className="text-subtitle m-0">
                      Stage {currentStage + 1}/{STAGES.length}
                    </span>
                  </div>
                  <div className="flex flex-row gap-1 sm:gap-2 items-center">
                    <CustomButton
                      variant="secondary"
                      icon={<LightbulbFilamentIcon size={16} />}
                      onClick={() => setShowHints(!showHints)}
                      aria-label="Toggle hints"
                      className="text-sm px-2 py-2 min-w-10"
                    >
                      <span className="hidden sm:inline text-sm">Hints</span>
                    </CustomButton>
                    <CustomButton
                      variant="secondary"
                      icon={<GridIcon size={16} />}
                      onClick={() => setShowGrid(!showGrid)}
                      aria-label="Toggle grid"
                      className="text-sm px-2 py-2 min-w-10"
                    >
                      <span className="hidden sm:inline text-sm">Grid</span>
                    </CustomButton>
                    <CustomButton
                      variant="secondary"
                      icon={<ArrowCounterClockwiseIcon size={16} />}
                      onClick={resetPositions}
                      aria-label="Reset positions"
                      className="text-sm px-2 py-2 min-w-10"
                    >
                      <span className="hidden sm:inline text-sm">Reset</span>
                    </CustomButton>
                  </div>
                </div>
              </div>
            )}

            <CustomDialog open={showSuccess} onOpenChange={setShowSuccess}>
              <div className="flex flex-col items-center gap-4 p-4">
                <h2 className="text-title flex items-center gap-2 text-center">
                  <TrophyIcon className="trophy-icon" size={28} />
                  {currentStage < STAGES.length - 1
                    ? "Stage Complete!"
                    : "Game Complete!"}
                </h2>
                <p className="text-body text-center">
                  {currentStage < STAGES.length - 1
                    ? "Congratulations! You've completed this stage!"
                    : "Amazing! You've completed all stages!"}
                </p>
                {currentStage < STAGES.length - 1 && (
                  <div className="mt-4 flex justify-center">
                    <CustomButton
                      variant="primary"
                      icon={<CaretRightIcon size={20} />}
                      onClick={advanceToNextStage}
                      className="text-base"
                    >
                      Next Stage
                    </CustomButton>
                  </div>
                )}
              </div>
            </CustomDialog>
          </div>
        );
      }

      const root = createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
