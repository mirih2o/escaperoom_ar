<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <title>AR Puzzle Game</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <!-- THREE.js library (required by AR.js THREEx) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- AR.js THREEx for marker detection -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex.js"></script>
    <style>
      body {
        font-family: "Inter", sans-serif;
        margin: 0;
        overflow: hidden; /* Prevent scrolling */
        touch-action: none; /* Prevent default touch behaviors */
      }
      /* Fix for touch event passive listener warnings */
      * {
        touch-action: manipulation;
      }
      /* Custom styles to mimic Spark components or enhance appearance */
      .dialog-overlay {
        background-color: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
      }
      .dialog-content {
        background-color: #ffffff;
        border-radius: 0.75rem;
        padding: 1.5rem;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1),
          0 10px 10px -5px rgba(0, 0, 0, 0.04);
        max-width: 24rem; /* max-w-sm */
        width: 90%; /* w-11/12 */
        border: 1px solid rgba(229, 231, 235, 0.8);
      }
      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem 2rem;
        border-radius: 1rem;
        font-weight: 600;
        transition: all 0.3s ease;
        min-height: 60px;
        font-size: 1rem;
        border: none;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
      }
      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
      }
      .btn-primary:active {
        transform: translateY(0);
        box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
      }
      .btn-secondary {
        background: rgba(255, 255, 255, 0.9);
        color: #4a5568;
        padding: 0.5rem 0.75rem;
        border-radius: 0.5rem;
        font-weight: 500;
        transition: all 0.3s ease;
        min-height: 44px;
        min-width: 44px;
        font-size: 0.75rem;
        border: 2px solid rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(10px);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.95);
        transform: translateY(-1px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
      }
      .btn-secondary:active {
        transform: translateY(0);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      /* Responsive font sizes for different screen sizes */
      @media (min-width: 640px) {
        .btn-primary {
          font-size: 1.125rem;
          padding: 1.25rem 2.5rem;
        } /* text-lg */
        .btn-secondary {
          font-size: 1rem;
          padding: 1rem 1.5rem;
        } /* text-base */
      }

      @media (min-width: 768px) {
        .btn-primary {
          font-size: 1.25rem;
          padding: 1.5rem 3rem;
        } /* text-xl */
        .btn-secondary {
          font-size: 1.125rem;
          padding: 1.25rem 2rem;
        } /* text-lg */
      }
      .text-accent-9 {
        color: #6366f1; /* A shade of indigo, for accent */
      }
      .text-accent-11 {
        color: #3730a3; /* A darker shade of indigo */
      }
      .bg-neutral-3 {
        background-color: rgba(
          229,
          231,
          235,
          0.9
        ); /* Light gray with some transparency */
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- React CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>
    <!-- Babel CDN for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useState, useRef, useEffect } = React;
      const { createRoot } = ReactDOM;

      // Inline SVG Icons (Phosphor Icons replacements)
      const TrophyIcon = ({ size = 24, className = "" }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          fill="currentColor"
          viewBox="0 0 256 256"
          className={className}
        >
          <path d="M228,104a12.1,12.1,0,0,0-12,12V160a48,48,0,0,1-48,48H88a48,48,0,0,1-48-48V116a12.1,12.1,0,0,0-12-12,12,12,0,0,0,0,24v40a24,24,0,0,0,24,24h88a24,24,0,0,0,24-24V128a12,12,0,0,0,24,0v-12A12.1,12.1,0,0,0,228,104Zm-96-8A64,64,0,0,0,68,92V36a12,12,0,0,1,24,0V92a40,40,0,0,1,80,0V36a12,12,0,0,1,24,0V92A64,64,0,0,0,132,96Zm92-48a12,12,0,0,0-12-12H48a12,12,0,0,0,0,24H212A12,12,0,0,0,224,48Z"></path>
        </svg>
      );

      const CameraIcon = ({ size = 24, className = "" }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          fill="currentColor"
          viewBox="0 0 256 256"
          className={className}
        >
          <path d="M216,48H176L160,28A16,16,0,0,0,146.51,20H109.49A16,16,0,0,0,96,28L80,48H40A24,24,0,0,0,16,72V200a24,24,0,0,0,24,24H216a24,24,0,0,0,24-24V72A24,24,0,0,0,216,48ZM128,192a48,48,0,1,1,48-48A48.05,48.05,0,0,1,128,192Zm0-72a24,24,0,1,0,24,24A24,24,0,0,0,128,120Z"></path>
        </svg>
      );

      const ArrowCounterClockwiseIcon = ({ size = 24, className = "" }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          fill="currentColor"
          viewBox="0 0 256 256"
          className={className}
        >
          <path d="M224,128a96,96,0,0,1-192,0,12,12,0,0,1,24,0,72,72,0,1,0,144,0,12,12,0,0,1,24,0Zm-91.13,10.34a12,12,0,0,0,17.43-1.63L168,96.34V64a12,12,0,0,0-24,0V82.34L117.63,65.34a12,12,0,0,0-15.5,18.17l23.5,20Z"></path>
        </svg>
      );

      const GridIcon = ({ size = 24, className = "" }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          fill="currentColor"
          viewBox="0 0 256 256"
          className={className}
        >
          <path d="M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM112,200H40V144h72Zm0-72H40V72h72Zm24,72v-56h72V200Zm72-72H136V72h72Z"></path>
        </svg>
      );

      const CaretRightIcon = ({ size = 24, className = "" }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          fill="currentColor"
          viewBox="0 0 256 256"
          className={className}
        >
          <path d="M184.49,136.49l-80,80a12,12,0,0,1-17-17L159,128,87.51,56.49a12,12,0,1,1,17-17l80,80A12,12,0,0,1,184.49,136.49Z"></path>
        </svg>
      );

      const LightbulbFilamentIcon = ({ size = 24, className = "" }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          fill="currentColor"
          viewBox="0 0 256 256"
          className={className}
        >
          <path d="M128,24A96,96,0,0,0,51,180.3L40.7,208H215.3l-10.3-27.7A96,96,0,0,0,128,24Zm-4.1,137.9a12,12,0,0,1-16.1,4.4,12,12,0,0,1-4.4-16.1L121.9,128,107.4,98.6a12,12,0,0,1,4.4-16.1,12,12,0,0,1,16.1,4.4L134.1,128l14.5,29.4A12,12,0,0,1,123.9,161.9ZM168,208v16a8,8,0,0,1-16,0V208ZM88,208v16a8,8,0,0,1-16,0V208Z"></path>
        </svg>
      );

      // Calculate grid cell size based on viewport
      const GRID_SIZE = 3;
      const TOLERANCE = 50; // Fixed tolerance value

      // Define stages with their symbols and winning positions
      const STAGES = [
        {
          symbols: {
            flame: {
              emoji: "üî•",
              position: null, // Will be calculated dynamically
              color: "#ff4400",
              hint: "The flame burns brightest on the right",
            },
            gear: {
              emoji: "‚öôÔ∏è",
              position: null, // Will be calculated dynamically
              color: "#888888",
              hint: "The gear sits in a corner",
            },
            eye: {
              emoji: "üëÅÔ∏è",
              position: null, // Will be calculated dynamically
              color: "#00ffff",
              hint: "The eye watches from above",
            },
          },
          winningPositions: {
            flame: { col: 2, row: 1 }, // Middle-right
            gear: { col: 0, row: 2 }, // Bottom-left
            eye: { col: 1, row: 0 }, // Top-center
          },
          neutralHints: {
            hint: "Each column and row has 1 symbol",
          },
        },
        {
          symbols: {
            flame: {
              emoji: "üî•",
              position: null, // Will be calculated dynamically
              color: "#ff4400",
              hint: "The flame glows from above",
            },
            gear: {
              emoji: "‚öôÔ∏è",
              position: null, // Will be calculated dynamically
              color: "#888888",
              hint: "The gear turns in harmony with others",
            },
            eye: {
              emoji: "üëÅÔ∏è",
              position: null, // Will be calculated dynamically
              color: "#00ffff",
              hint: "The eye keeps balance in the center",
            },
            star: {
              emoji: "‚≠ê",
              position: null, // Will be calculated dynamically
              color: "#ffff00",
              hint: "The star guides from the eastern edge",
            },
            moon: {
              emoji: "üåô",
              position: null, // Will be calculated dynamically
              color: "#cccccc",
              hint: "The moon reflects light from below",
            },
            sun: {
              emoji: "‚òÄÔ∏è",
              position: null, // Will be calculated dynamically
              color: "#ffaa00",
              hint: "The sun brings warmth to the west",
            },
          },
          neutralHints: {
            hint: "Arrange the symbols.",
          },
          winningPositions: {
            flame: { col: 1, row: 0 }, // Top-center
            gear: { col: 0, row: 1 }, // Middle-left
            eye: { col: 1, row: 1 }, // Center
            star: { col: 2, row: 1 }, // Middle-right
            moon: { col: 1, row: 2 }, // Bottom-center
            sun: { col: 0, row: 0 }, // Top-left
          },
        },
      ];

      function App() {
        const [currentStage, setCurrentStage] = useState(0);
        const [isARActive, setIsARActive] = useState(false);
        const [arInitialized, setArInitialized] = useState(false);
        const [arError, setArError] = useState(null);
        const [showSuccess, setShowSuccess] = useState(false);
        const [showGrid, setShowGrid] = useState(false);
        const [showHints, setShowHints] = useState(false);
        const [draggedSymbol, setDraggedSymbol] = useState(null);
        const [cursorPosition, setCursorPosition] = useState({ x: 0, y: 0 }); // Not currently used for symbol position
        // Track which symbols have been discovered via AR markers
        const [discoveredSymbols, setDiscoveredSymbols] = useState(new Set());
        const [positions, setPositions] = useState({});
        const [showAllSymbolsFoundMessage, setShowAllSymbolsFoundMessage] = useState(false);

        const [cellSize, setCellSize] = useState(0);
        const [gridOffsetX, setGridOffsetX] = useState(0);
        const [gridOffsetY, setGridOffsetY] = useState(0);

        const videoRef = useRef(null);
        const containerRef = useRef(null);
        const arToolkitSourceRef = useRef(null);
        const arToolkitContextRef = useRef(null);
        const markerControlsRef = useRef({});

        // Calculate initial symbol positions based on available space
        const calculateInitialPositions = (stage) => {
          const topUIHeight = 80;
          const sidePadding = 40; // More generous padding
          
          // Calculate symbol area (above the grid)
          const symbolAreaWidth = window.innerWidth - (sidePadding * 2);
          const symbolAreaTop = 10; // Small margin from very top
          const symbolAreaHeight = 50; // Height for symbol placement
          
          const symbols = Object.keys(STAGES[stage].symbols);
          const positions = {};
          
          // Arrange symbols horizontally with even spacing
          if (symbols.length > 0) {
            symbols.forEach((symbol, index) => {
              const spacing = symbolAreaWidth / symbols.length;
              const xOffset = spacing * index + spacing / 2;
              
              positions[symbol] = {
                x: sidePadding + xOffset,
                y: symbolAreaTop + symbolAreaHeight / 2
              };
            });
          }
          
          return positions;
        };

        // AR marker detection function
        const onMarkerDetected = (markerId) => {
          // Map marker IDs to symbol names
          const markerToSymbol = {
            'eye': 'eye',
            'flame': 'flame', 
            'gear': 'gear'
          };
          
          const symbolName = markerToSymbol[markerId];
          if (symbolName && currentStage === 0) {
            setDiscoveredSymbols(prev => new Set([...prev, symbolName]));
          }
        };

        // Implement actual AR marker detection
        const initializeAR = () => {
          console.log('Initializing AR marker detection...');
          
          // Check if AR.js is properly loaded
          if (typeof THREEx === 'undefined' || typeof THREE === 'undefined') {
            console.warn('AR.js libraries not fully loaded, using manual mode');
            setArError('AR libraries not loaded');
            setArInitialized(true);
            return;
          }

          try {
            // Create AR toolkit source with camera access
            arToolkitSourceRef.current = new THREEx.ArToolkitSource({
              sourceType: 'webcam',
              sourceWidth: window.innerWidth,
              sourceHeight: window.innerHeight,
              displayWidth: window.innerWidth,
              displayHeight: window.innerHeight,
            });

            arToolkitSourceRef.current.init(() => {
              console.log('AR source initialized successfully');
              
              // Show the camera feed in the video element
              if (videoRef.current && arToolkitSourceRef.current.domElement) {
                // Copy the video stream to our video element for display
                const sourceVideo = arToolkitSourceRef.current.domElement;
                if (sourceVideo.srcObject) {
                  videoRef.current.srcObject = sourceVideo.srcObject;
                  videoRef.current.play();
                }
              }
              
              // Create AR toolkit context
              arToolkitContextRef.current = new THREEx.ArToolkitContext({
                cameraParametersUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/data/data/camera_para.dat',
                detectionMode: 'mono_and_matrix',
                matrixCodeType: '3x3',
                canvasWidth: arToolkitSourceRef.current.parameters.sourceWidth,
                canvasHeight: arToolkitSourceRef.current.parameters.sourceHeight,
              });

              arToolkitContextRef.current.init(() => {
                console.log('AR context initialized successfully');
                
                // Create Three.js scene for AR
                const scene = new THREE.Scene();
                const camera = new THREE.Camera();
                scene.add(camera);

                // Setup markers for each pattern file
                const markers = [
                  { id: 'eye', patternUrl: './markers/eye.patt' },
                  { id: 'flame', patternUrl: './markers/flame.patt' },
                  { id: 'gear', patternUrl: './markers/gear.patt' }
                ];
                
                markers.forEach(marker => {
                  const markerRoot = new THREE.Group();
                  scene.add(markerRoot);

                  const markerControls = new THREEx.ArMarkerControls(arToolkitContextRef.current, markerRoot, {
                    type: 'pattern',
                    patternUrl: marker.patternUrl,
                    changeMatrixMode: 'cameraTransformMatrix'
                  });

                  // Store reference
                  markerControlsRef.current[marker.id] = markerControls;

                  // Track marker visibility
                  let isMarkerVisible = false;

                  // Create a detection loop for this marker
                  const checkMarkerVisibility = () => {
                    const wasVisible = isMarkerVisible;
                    isMarkerVisible = markerRoot.visible;

                    if (!wasVisible && isMarkerVisible) {
                      console.log(`Marker ${marker.id} detected!`);
                      onMarkerDetected(marker.id);
                    } else if (wasVisible && !isMarkerVisible) {
                      console.log(`Marker ${marker.id} lost`);
                    }
                  };

                  // Add to detection loop
                  markerControlsRef.current[marker.id].checkVisibility = checkMarkerVisibility;
                });

                // Start the AR render loop
                startARRenderLoop();
                
                console.log('AR marker detection fully initialized');
                setArInitialized(true);
                
              }, (error) => {
                console.error('AR context initialization failed:', error);
                setArError('AR context failed');
                setArInitialized(true); // Fallback to manual mode
              });
              
            }, (error) => {
              console.error('AR source initialization failed:', error);
              setArError('Camera access failed');
              setArInitialized(true); // Fallback to manual mode
            });
            
          } catch (error) {
            console.error('AR initialization error:', error);
            setArError('AR initialization failed');
            setArInitialized(true); // Fallback to manual mode
          }
        };

        // AR render loop with marker detection
        const startARRenderLoop = () => {
          const animate = () => {
            requestAnimationFrame(animate);
            
            if (arToolkitSourceRef.current && arToolkitContextRef.current) {
              if (arToolkitSourceRef.current.ready) {
                arToolkitContextRef.current.update(arToolkitSourceRef.current.domElement);
                
                // Check marker visibility for each marker
                Object.values(markerControlsRef.current).forEach(markerControls => {
                  if (markerControls.checkVisibility) {
                    markerControls.checkVisibility();
                  }
                });
              }
            }
          };
          animate();
        };

        // Cleanup AR resources
        const cleanupAR = () => {
          if (arToolkitContextRef.current) {
            arToolkitContextRef.current.dispose();
            arToolkitContextRef.current = null;
          }
          if (arToolkitSourceRef.current) {
            arToolkitSourceRef.current = null;
          }
          markerControlsRef.current = {};
          
          setArInitialized(false);
        };

        // Effect to reveal grid when all symbols are discovered in stage 1
        useEffect(() => {
          if (currentStage === 0 && discoveredSymbols.size === 3) {
            setShowGrid(true);
            setShowAllSymbolsFoundMessage(true);
            
            // Fade out the message after 3 seconds
            const timer = setTimeout(() => {
              setShowAllSymbolsFoundMessage(false);
            }, 3000);
            
            return () => clearTimeout(timer);
          }
        }, [discoveredSymbols, currentStage]);

        // Initial setup effect
        useEffect(() => {
          // Set initial positions on component mount
          const initialPositions = calculateInitialPositions(currentStage);
          setPositions(initialPositions);
        }, []);

        // Cleanup AR resources on unmount
        useEffect(() => {
          return () => {
            cleanupAR();
          };
        }, []);

        // Update grid dimensions and symbol positions on window resize
        useEffect(() => {
          const updateGridDimensions = () => {
            // Account for UI elements and safe areas
            const topUIHeight = 80; // Reduced space for top messages/indicators
            const bottomUIHeight = 120; // Reduced space for bottom controls
            const sidePadding = 20; // Minimum side padding
            
            const availableWidth = window.innerWidth - (sidePadding * 2);
            const availableHeight = window.innerHeight - topUIHeight - bottomUIHeight;
            const minDimension = Math.min(availableWidth, availableHeight);
            
            // Ensure grid fits well on screen with minimum cell size
            const newCellSize = Math.max(70, Math.min(110, minDimension / 3.5));
            setCellSize(newCellSize);
            
            // Center horizontally
            setGridOffsetX(
              window.innerWidth / 2 - (GRID_SIZE * newCellSize) / 2
            );
            
            // Center vertically in the available space
            const gridHeight = GRID_SIZE * newCellSize;
            setGridOffsetY(
              topUIHeight + (availableHeight - gridHeight) / 2
            );
            
            // Calculate and set initial positions for symbols
            const initialPositions = calculateInitialPositions(currentStage);
            setPositions(prev => ({ ...prev, ...initialPositions }));
          };

          updateGridDimensions();
          window.addEventListener("resize", updateGridDimensions);
          // Also update on orientation change for mobile
          window.addEventListener("orientationchange", () => {
            setTimeout(updateGridDimensions, 100);
          });

          return () => {
            window.removeEventListener("resize", updateGridDimensions);
            window.removeEventListener(
              "orientationchange",
              updateGridDimensions
            );
          };
        }, [currentStage]); // Add currentStage as dependency

        // Handle touch events with non-passive listeners to prevent warnings
        useEffect(() => {
          const handleTouchStartNonPassive = (e) => {
            const target = e.target;
            const symbolElement = target.closest('[data-symbol]');
            
            if (symbolElement) {
              e.preventDefault();
              const symbol = symbolElement.getAttribute('data-symbol');
              setDraggedSymbol(symbol);
            }
          };

          const handleTouchMoveNonPassive = (e) => {
            // Check if the target is the container or a draggable symbol
            const container = containerRef.current;
            const target = e.target;
            
            if (!container) return;
            
            // If it's the container or a child of the container
            if (container.contains(target)) {
              e.preventDefault();
              
              // Get touch coordinates
              const touch = e.touches?.[0] || e.changedTouches?.[0];
              const clientX = touch?.clientX || e.clientX;
              const clientY = touch?.clientY || e.clientY;
              
              const containerRect = container.getBoundingClientRect();
              const x = clientX - containerRect.left;
              const y = clientY - containerRect.top;
              
              // Check if it's a draggable symbol (has data-symbol attribute)
              const symbolElement = target.closest('[data-symbol]');
              if (symbolElement) {
                // Handle symbol dragging
                setPositions((prev) => {
                  const currentDraggedSymbol = Object.keys(prev).find(symbol => 
                    document.querySelector(`[data-symbol="${symbol}"]`) === symbolElement
                  );
                  
                  if (!currentDraggedSymbol) return prev;
                  
                  // Check if within grid bounds for snapping
                  const col = Math.floor((x - gridOffsetX) / cellSize);
                  const row = Math.floor((y - gridOffsetY) / cellSize);

                  if (col >= 0 && col < GRID_SIZE && row >= 0 && row < GRID_SIZE) {
                    // Snap to grid
                    const snappedX = gridOffsetX + (col + 0.5) * cellSize;
                    const snappedY = gridOffsetY + (row + 0.5) * cellSize;
                    return {
                      ...prev,
                      [currentDraggedSymbol]: { x: snappedX, y: snappedY },
                    };
                  } else {
                    // Follow cursor if not within grid
                    return {
                      ...prev,
                      [currentDraggedSymbol]: { x, y },
                    };
                  }
                });
              } else {
                // Handle cursor tracking
                setCursorPosition({ x, y });
              }
            }
          };

          const handleTouchEndNonPassive = (e) => {
            const target = e.target;
            const symbolElement = target.closest('[data-symbol]');
            
            if (symbolElement) {
              e.preventDefault();
              
              // Get the symbol being dropped
              const symbol = symbolElement.getAttribute('data-symbol');
              
              // Handle drop logic
              setPositions((prevPositions) => {
                const currentPos = prevPositions[symbol];
                if (!currentPos) return prevPositions;
                
                const col = Math.floor((currentPos.x - gridOffsetX) / cellSize);
                const row = Math.floor((currentPos.y - gridOffsetY) / cellSize);

                let updatedPositions = prevPositions;

                // Check if the cell is within grid bounds
                if (col >= 0 && col < GRID_SIZE && row >= 0 && row < GRID_SIZE) {
                  // Check if any other symbol is in this cell
                  const occupyingSymbol = Object.entries(prevPositions).find(
                    ([otherSymbol, pos]) => {
                      if (otherSymbol === symbol) return false;
                      const otherCol = Math.floor((pos.x - gridOffsetX) / cellSize);
                      const otherRow = Math.floor((pos.y - gridOffsetY) / cellSize);
                      return otherCol === col && otherRow === row;
                    }
                  );

                  if (!occupyingSymbol) {
                    // Cell is free, snap to grid center
                    updatedPositions = {
                      ...prevPositions,
                      [symbol]: {
                        x: gridOffsetX + (col + 0.5) * cellSize,
                        y: gridOffsetY + (row + 0.5) * cellSize,
                      },
                    };
                  }
                } else {
                  // Return to original position if drop is invalid
                  const initialPositions = calculateInitialPositions(currentStage);
                  updatedPositions = {
                    ...prevPositions,
                    [symbol]: initialPositions[symbol] || prevPositions[symbol],
                  };
                }
                
                // Check win condition with the updated positions
                setTimeout(() => {
                  let isWin = true;
                  const currentWinningPositions = STAGES[currentStage].winningPositions;

                  Object.entries(updatedPositions).forEach(([sym, position]) => {
                    const target = currentWinningPositions[sym];
                    if (!target) {
                      isWin = false;
                      return;
                    }
                    const targetPixel = {
                      x: gridOffsetX + (target.col + 0.5) * cellSize,
                      y: gridOffsetY + (target.row + 0.5) * cellSize,
                    };
                    const distance = Math.sqrt(
                      Math.pow(targetPixel.x - position.x, 2) +
                        Math.pow(targetPixel.y - position.y, 2)
                    );

                    if (distance > TOLERANCE) {
                      isWin = false;
                    }
                  });

                  if (isWin) {
                    setShowSuccess(true);
                  }
                }, 50);
                
                return updatedPositions;
              });
              
              setDraggedSymbol(null);
            }
          };

          // Add non-passive touch listeners to document
          document.addEventListener('touchstart', handleTouchStartNonPassive, { passive: false });
          document.addEventListener('touchmove', handleTouchMoveNonPassive, { passive: false });
          document.addEventListener('touchend', handleTouchEndNonPassive, { passive: false });

          return () => {
            document.removeEventListener('touchstart', handleTouchStartNonPassive);
            document.removeEventListener('touchmove', handleTouchMoveNonPassive);
            document.removeEventListener('touchend', handleTouchEndNonPassive);
          };
        }, [gridOffsetX, gridOffsetY, cellSize, currentStage]);

        // Convert grid position to pixel coordinates
        const gridToPixel = (col, row) => ({
          x: gridOffsetX + (col + 0.5) * cellSize,
          y: gridOffsetY + (row + 0.5) * cellSize,
        });

        // Convert pixel coordinates to grid position
        const pixelToGrid = (x, y) => ({
          col: Math.floor((x - gridOffsetX) / cellSize),
          row: Math.floor((y - gridOffsetY) / cellSize),
        });

        const getEventCoordinates = (e) => {
          const touch = e.touches?.[0] || e.changedTouches?.[0];
          return {
            clientX: touch?.clientX || e.clientX,
            clientY: touch?.clientY || e.clientY,
          };
        };

        const handlePointerMove = (e) => {
          const container = containerRef.current.getBoundingClientRect();
          const { clientX, clientY } = getEventCoordinates(e);
          const x = clientX - container.left;
          const y = clientY - container.top;
          setCursorPosition({ x, y });
        };

        const handleDragStart = (e, symbol) => {
          e.preventDefault();
          setDraggedSymbol(symbol);
        };

        const startAR = async () => {
          try {
            setIsARActive(true);
            
            // Try AR initialization first
            setTimeout(() => {
              initializeAR();
              
              // If AR fails, fallback to basic camera access after a delay
              setTimeout(() => {
                if (arError && videoRef.current && !videoRef.current.srcObject) {
                  console.log('AR failed, trying fallback camera access...');
                  navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "environment" }
                  }).then(stream => {
                    if (videoRef.current) {
                      videoRef.current.srcObject = stream;
                      videoRef.current.play();
                      console.log('Fallback camera initialized');
                    }
                  }).catch(err => {
                    console.error('Fallback camera access failed:', err);
                  });
                }
              }, 2000);
            }, 500);
            
          } catch (error) {
            console.error("Error starting AR:", error);
            // Provide a user-friendly message instead of alert
            const messageBox = document.createElement("div");
            messageBox.className =
              "fixed inset-0 flex items-center justify-center z-[100] dialog-overlay";
            messageBox.innerHTML = `
                        <div class="dialog-content text-center">
                            <h2 class="text-xl sm:text-2xl md:text-3xl font-semibold mb-6">AR Initialization Failed</h2>
                            <p class="text-base sm:text-lg md:text-xl mb-6">Please try again or use manual mode.</p>
                            <button class="mt-6 px-6 py-3 bg-blue-500 text-white rounded-lg text-base sm:text-lg md:text-xl hover:bg-blue-600 transition-colors font-medium" onclick="this.parentElement.parentElement.remove()">OK</button>
                        </div>
                    `;
            document.body.appendChild(messageBox);
          }
        };

        const checkWinCondition = () => {
          let isWin = true;
          const currentWinningPositions = STAGES[currentStage].winningPositions;

          Object.entries(positions).forEach(([symbol, position]) => {
            const target = currentWinningPositions[symbol];
            if (!target) {
              // Handle cases where a symbol might not have a winning position in the current stage
              isWin = false;
              return;
            }
            const targetPixel = gridToPixel(target.col, target.row);
            const distance = Math.sqrt(
              Math.pow(targetPixel.x - position.x, 2) +
                Math.pow(targetPixel.y - position.y, 2)
            );

            if (distance > TOLERANCE) {
              isWin = false;
            }
          });

          if (isWin) {
            setShowSuccess(true);
          }
        };

        const advanceToNextStage = () => {
          if (currentStage < STAGES.length - 1) {
            const nextStageIndex = currentStage + 1;
            setCurrentStage(nextStageIndex);
            // Reset positions for the new stage symbols will be handled by useEffect
            setShowSuccess(false);
            setShowHints(false); // Hide hints for new stage
            // Reset AR discovery for the new stage
            setDiscoveredSymbols(new Set());
            // For stages other than 1, show grid by default
            if (nextStageIndex !== 0) {
              setShowGrid(true);
            } else {
              setShowGrid(false);
            }
          }
        };

        const resetPositions = () => {
          const initialPositions = calculateInitialPositions(currentStage);
          setPositions(prev => ({ ...prev, ...initialPositions }));
        };

        const snapToGrid = (x, y) => {
          // Calculate which grid cell we're closest to
          const col = Math.floor((x - gridOffsetX) / cellSize);
          const row = Math.floor((y - gridOffsetY) / cellSize);

          // Only snap if within grid bounds
          if (col >= 0 && col < GRID_SIZE && row >= 0 && row < GRID_SIZE) {
            return gridToPixel(col, row);
          }

          // Return original position if not within grid
          return { x, y };
        };

        const handleDrag = (e) => {
          if (!draggedSymbol) return;
          e.preventDefault();

          const container = containerRef.current.getBoundingClientRect();
          const { clientX, clientY } = getEventCoordinates(e);
          const x = clientX - container.left;
          const y = clientY - container.top;

          // Check if within grid bounds for snapping
          const col = Math.floor((x - gridOffsetX) / cellSize);
          const row = Math.floor((y - gridOffsetY) / cellSize);

          if (col >= 0 && col < GRID_SIZE && row >= 0 && row < GRID_SIZE) {
            const snappedPos = snapToGrid(x, y);
            setPositions((prev) => ({
              ...prev,
              [draggedSymbol]: snappedPos,
            }));
          } else {
            // Follow cursor if not within grid
            setPositions((prev) => ({
              ...prev,
              [draggedSymbol]: { x, y },
            }));
          }
        };

        const handleDragEnd = () => {
          if (!draggedSymbol) return;

          const currentPos = positions[draggedSymbol];
          const gridPos = pixelToGrid(currentPos.x, currentPos.y);

          // Check if the cell is within grid bounds
          if (
            gridPos.col >= 0 &&
            gridPos.col < GRID_SIZE &&
            gridPos.row >= 0 &&
            gridPos.row < GRID_SIZE
          ) {
            // Check if any other symbol is in this cell
            const occupyingSymbol = Object.entries(positions).find(
              ([symbol, pos]) => {
                if (symbol === draggedSymbol) return false;
                const otherGridPos = pixelToGrid(pos.x, pos.y);
                return (
                  otherGridPos.col === gridPos.col &&
                  otherGridPos.row === gridPos.row
                );
              }
            );

            // If cell is occupied, send the other symbol back to its original position
            if (occupyingSymbol) {
              const [symbol] = occupyingSymbol;
              const initialPositions = calculateInitialPositions(currentStage);
              setPositions((prev) => ({
                ...prev,
                [symbol]: initialPositions[symbol],
              }));
            }
          }

          setDraggedSymbol(null);
          checkWinCondition();
        };

        // Custom Dialog component replacement
        const CustomDialog = ({ open, onOpenChange, children }) => {
          if (!open) return null;
          return (
            <div
              className="fixed inset-0 flex items-center justify-center z-50 dialog-overlay"
              onClick={() => onOpenChange(false)}
            >
              <div
                className="dialog-content"
                onClick={(e) => e.stopPropagation()}
              >
                {children}
              </div>
            </div>
          );
        };

        // Custom Button component replacement
        const CustomButton = ({
          variant,
          icon,
          onClick,
          children,
          className,
          "aria-label": ariaLabel,
        }) => {
          const baseClasses =
            "flex items-center justify-center gap-2 font-medium transition-all";
          const variantClasses = {
            primary: "btn-primary",
            secondary: "btn-secondary",
          };

          return (
            <button
              className={`${baseClasses} ${variantClasses[variant]} ${className || ''}`}
              onClick={onClick}
              aria-label={ariaLabel}
            >
              {icon}
              {children}
            </button>
          );
        };

        return (
          <div
            className="w-full h-screen relative overflow-hidden"
            ref={containerRef}
            onDragOver={(e) => e.preventDefault()}
            onMouseMove={handlePointerMove}
            style={{ touchAction: "none" }}
          >
            <video
              ref={videoRef}
              className="w-full h-full object-cover"
              playsInline
              muted
              hidden={!isARActive}
            />

            {showGrid &&
              cellSize >
                0 /* Ensure cellSize is calculated before rendering grid */ && (
                <div
                  className="absolute grid grid-cols-3 grid-rows-3"
                  style={{
                    width: GRID_SIZE * cellSize,
                    height: GRID_SIZE * cellSize,
                    left: gridOffsetX,
                    top: gridOffsetY,
                  }}
                >
                  {Array.from({ length: 9 }).map((_, i) => (
                    <div key={i} className="border-2 border-white/60 bg-white/10 backdrop-blur-sm" />
                  ))}
                </div>
              )}

            {Object.entries(STAGES[currentStage].symbols)
              .filter(([symbol]) => {
                // In stage 1, only show symbols that have been discovered via AR markers
                return currentStage !== 0 || discoveredSymbols.has(symbol);
              })
              .map(([symbol, config]) => {
                // Ensure position exists, if not use fallback
                const symbolPosition = positions[symbol] || { x: 50, y: 50 };
                
                return (
                  <div
                    key={symbol}
                    className="absolute cursor-move text-3xl sm:text-4xl md:text-5xl select-none touch-none"
                    data-symbol={symbol}
                    style={{
                      left: symbolPosition.x,
                      top: symbolPosition.y,
                      transform: "translate(-50%, -50%)",
                      zIndex: draggedSymbol === symbol ? 10 : 5, // Bring dragged symbol to front
                      filter:
                        draggedSymbol === symbol
                          ? "drop-shadow(0 4px 8px rgba(0,0,0,0.3))"
                          : "drop-shadow(0 2px 4px rgba(0,0,0,0.2))",
                      transition:
                        draggedSymbol === symbol ? "none" : "all 0.2s ease",
                    }}
                    draggable
                    onDragStart={(e) => handleDragStart(e, symbol)}
                    onDrag={handleDrag}
                    onDragEnd={handleDragEnd}
                  >
                    {config.emoji}
                  </div>
                );
              }
            )}

            {showHints && (
              <div className="fixed left-2 right-2 z-20" style={{ bottom: '100px' }}>
                <div className="bg-white/95 backdrop-blur-sm p-3 rounded-lg shadow-lg border border-gray-200 max-w-md mx-auto">
                  <div className="text-center text-sm text-gray-800 font-medium mb-1">
                    <LightbulbFilamentIcon className="text-yellow-500 inline mr-1" size={16} />
                    Puzzle Hints
                  </div>
                  <div className="text-xs text-gray-600 space-y-1">
                    {STAGES[currentStage].neutralHints?.hint && (
                      <div className="text-center mb-2">
                        {STAGES[currentStage].neutralHints.hint}
                      </div>
                    )}
                    {Object.entries(STAGES[currentStage].symbols)
                      .filter(([symbol]) => {
                        // In stage 1, only show hints for symbols that have been discovered via AR markers
                        return currentStage !== 0 || discoveredSymbols.has(symbol);
                      })
                      .map(([symbol, config]) => (
                        <div
                          key={symbol}
                          className="flex items-center gap-2"
                        >
                          <span className="text-sm">
                            {config.emoji}
                          </span>
                          <span>
                            {config.hint}
                          </span>
                        </div>
                      )
                    )}
                  </div>
                </div>
              </div>
            )}

            {!isARActive && (
              <div className="absolute inset-0 flex items-center justify-center z-10 bg-gradient-to-br from-blue-50 to-indigo-100">
                <div className="text-center p-6 bg-white rounded-xl shadow-lg border border-gray-200 max-w-sm mx-4">
                  <h2 className="text-xl font-semibold text-gray-800 mb-3">AR Puzzle Game</h2>
                  <CustomButton
                    variant="primary"
                    icon={<CameraIcon size={20} />}
                    onClick={startAR}
                    className="w-full"
                  >
                    Start AR Experience
                  </CustomButton>
                  <p className="mt-3 text-sm text-gray-600">
                    Find and scan AR markers to discover hidden symbols and unlock the puzzle grid
                  </p>
                </div>
              </div>
            )}

            {/* AR Scanning Instructions for Stage 1 */}
            {isARActive && currentStage === 0 && discoveredSymbols.size < 3 && (
              <div className="fixed top-2 left-2 right-2 bg-white/95 backdrop-blur-sm p-3 rounded-lg z-20 shadow-lg border border-gray-200 max-w-md mx-auto">
                <div className="text-center">
                  <h3 className="text-base sm:text-lg font-semibold text-gray-800 mb-1">
                    {arError ? '‚ö†Ô∏è Using Manual Mode' : arInitialized ? 'üîç Find Hidden Symbols' : 'üì∑ Starting Camera...'}
                  </h3>
                  <p className="text-xs sm:text-sm text-gray-600 mb-2">
                    {arError ? 'Camera ready - Use manual buttons below' : arInitialized 
                      ? 'Point camera at markers or tap buttons below'
                      : 'Setting up detection...'
                    }
                  </p>
                  {arInitialized && (
                    <>
                      <div className="flex justify-center items-center gap-3 mb-2">
                        <span className="text-sm font-medium text-gray-700">
                          {discoveredSymbols.size}/3
                        </span>
                        <div className="flex gap-1">
                          {['eye', 'flame', 'gear'].map((symbol) => (
                            <span
                              key={symbol}
                              className={`text-lg transition-all duration-300 ${
                                discoveredSymbols.has(symbol) 
                                  ? 'opacity-100 scale-110' 
                                  : 'opacity-20 scale-90'
                              }`}
                            >
                              {symbol === 'eye' ? 'üëÅÔ∏è' : symbol === 'flame' ? 'üî•' : '‚öôÔ∏è'}
                            </span>
                          ))}
                        </div>
                      </div>
                      <div className="flex items-center justify-center gap-1 text-green-600 text-xs">
                        <div className="w-1.5 h-1.5 bg-green-500 rounded-full animate-pulse"></div>
                        AR Active
                      </div>
                    </>
                  )}
                  {!arInitialized && (
                    <div className="flex justify-center items-center gap-2">
                      <div className="animate-spin rounded-full h-4 w-4 border-2 border-b-transparent border-blue-600"></div>
                      <button
                        onClick={() => setArInitialized(true)}
                        className="px-2 py-1 text-xs bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition-colors"
                      >
                        Skip
                      </button>
                    </div>
                  )}
                </div>
              </div>
            )}

            {/* Grid revealed message for Stage 1 */}
            {isARActive && currentStage === 0 && discoveredSymbols.size === 3 && showGrid && (
              <div 
                className={`fixed top-20 left-2 right-2 bg-green-50 border border-green-200 p-3 rounded-lg z-20 shadow-lg max-w-md mx-auto transition-opacity duration-1000 ${
                  showAllSymbolsFoundMessage ? 'opacity-100' : 'opacity-0'
                }`}
              >
                <div className="text-center">
                  <h3 className="text-base font-semibold text-green-800 mb-1 flex items-center justify-center gap-2">
                    ‚úÖ All Symbols Found!
                  </h3>
                  <p className="text-sm text-green-700">
                    Drag symbols to solve the puzzle.
                  </p>
                </div>
              </div>
            )}

            {isARActive && (
              <div className="fixed bottom-0 left-0 right-0 z-20 p-2">
                {/* Development/Fallback AR testing buttons */}
                {currentStage === 0 && discoveredSymbols.size < 3 && (
                  <div className="bg-white/95 backdrop-blur-sm p-3 rounded-lg shadow-lg border border-gray-200 mb-2 max-w-md mx-auto">
                    <div className="text-center text-sm text-gray-800 font-medium mb-1">
                      Tap if AR scanning doesn't work
                    </div>
                    <div className="flex justify-center gap-2 flex-wrap">
                      {['eye', 'flame', 'gear'].map((symbol) => (
                        <button
                          key={symbol}
                          onClick={() => onMarkerDetected(symbol)}
                          disabled={discoveredSymbols.has(symbol)}
                          className={`px-3 py-2 rounded-lg text-sm font-medium transition-all flex-shrink-0 ${
                            discoveredSymbols.has(symbol)
                              ? 'bg-green-100 text-green-800 cursor-not-allowed'
                              : 'bg-blue-500 text-white hover:bg-blue-600 active:scale-95'
                          }`}
                        >
                          {symbol === 'eye' ? 'üëÅÔ∏è Eye' : symbol === 'flame' ? 'üî• Flame' : '‚öôÔ∏è Gear'}
                        </button>
                      ))}
                    </div>
                  </div>
                )}

                <div className="flex flex-row justify-between items-center bg-white/95 backdrop-blur-sm p-3 rounded-lg shadow-lg border border-gray-200 max-w-md mx-auto">
                  <div className="flex items-center gap-3">
                    <span className="text-sm font-semibold text-gray-800">
                      Stage {currentStage + 1}/{STAGES.length}
                    </span>
                  </div>
                  <div className="flex flex-row gap-1 sm:gap-2 items-center">
                  <CustomButton
                    variant="secondary"
                    icon={<LightbulbFilamentIcon size={16} />}
                    onClick={() => setShowHints(!showHints)}
                    aria-label="Toggle hints"
                    className="text-xs px-2 py-2 min-w-10"
                  >
                    <span className="hidden sm:inline text-xs">
                      Hints
                    </span>
                  </CustomButton>
                  <CustomButton
                    variant="secondary"
                    icon={<GridIcon size={16} />}
                    onClick={() => setShowGrid(!showGrid)}
                    aria-label="Toggle grid"
                    className="text-xs px-2 py-2 min-w-10"
                  >
                    <span className="hidden sm:inline text-xs">
                      Grid
                    </span>
                  </CustomButton>
                  <CustomButton
                    variant="secondary"
                    icon={<ArrowCounterClockwiseIcon size={16} />}
                    onClick={resetPositions}
                    aria-label="Reset positions"
                    className="text-xs px-2 py-2 min-w-10"
                  >
                    <span className="hidden sm:inline text-xs">
                      Reset
                    </span>
                  </CustomButton>
                  </div>
                </div>
              </div>
            )}

            <CustomDialog open={showSuccess} onOpenChange={setShowSuccess}>
              <div className="flex flex-col items-center gap-4 p-4">
                <h2 className="text-xl sm:text-2xl font-semibold flex items-center gap-2 text-center">
                  <TrophyIcon className="text-yellow-500" size={28} />
                  {currentStage < STAGES.length - 1
                    ? "Stage Complete!"
                    : "Game Complete!"}
                </h2>
                <p className="text-center text-base text-gray-700">
                  {currentStage < STAGES.length - 1
                    ? "Congratulations! You've completed this stage!"
                    : "Amazing! You've completed all stages!"}
                </p>
                {currentStage < STAGES.length - 1 && (
                  <div className="mt-4 flex justify-center">
                    <CustomButton
                      variant="primary"
                      icon={<CaretRightIcon size={20} />}
                      onClick={advanceToNextStage}
                      className="text-base"
                    >
                      Next Stage
                    </CustomButton>
                  </div>
                )}
              </div>
            </CustomDialog>
          </div>
        );
      }

      const root = createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
